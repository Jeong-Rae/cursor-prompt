## Default Setting

-   응답은 한국어 (Korean)을 기준으로 한다.

## Task 기반 개발 라이프 사이클

1. **`Task` 정의**
   `Task`란 사용자의 단일 요청부터 응답이 완료될 때까지의 전체 흐름을 의미합니다.

2. **`Task`의 5단계 구성**

    1. 요구사항 분석
    2. 테스트 작성
    3. 코드 로직 구현
    4. 빌드
    5. curl 기반 E2E(end-to-end) 검증

3. **요구사항 분석**

    - 사용자가 한 번의 요청으로 여러 세부 요구사항을 제시할 수 있으며, 이들 요구사항이 불완전할 수도 있습니다.
    - 다음 단계로 진행하기 전에 반드시 아래를 수행해야 합니다.

        1. 사용자 요청 내용을 면밀히 검토
        2. 기존 코드베이스와의 연관성 파악
        3. 무엇을 개발하고, 어떤 부분을 보완·작성해야 하는지 명확히 정의

4. **테스트 작성**

    - 테스트는 기본적으로 유닛 테스트를 지향합니다.
    - BDD 방식의 서술(given–when–then)을 선호합니다.
    - 테스트 수행 전, 명확한 Input과 Output을 사전에 정의하고, 호출할 메서드명 및 인자 설계를 완료해야 합니다.
    - 테스트 코드를 작성하며 정의한 Input과 Output을 검증합니다.
    - 올바른 응답뿐만 아니라 다양한 예외 사항도 추가로 검증하며, 주로 경계값을 인자로 사용합니다.
    - 테스트는 오직 해당 메서드의 인자와 출력값만 검증하고, 다른 메서드 및 외부 의존성은 별도의 테스트가 검증했다고 가정하여 이중 검증을 피합니다.

5. **코드 로직 구현**

    - 확장 가능한 선언적 코드 구조를 선호합니다.
    - 기본적으로 인터페이스 기반의 컨트랙트가 잘 짜여진 코드를 작성해야 합니다.
    - 매직넘버 및 상수는 불변값으로 별도 변수에 정의하며, 카테고리가 있는 상수는 Enum과 유사한 형태로 정의합니다.
    - 코드는 단일 책임 원칙을 준수하며, 비즈니스 로직과 유틸리티 로직을 엄격하게 구분합니다.
    - public 메서드는 private 메서드를 호출하여 기능 흐름을 구조화해야 합니다.
    - 조건문에 사용되는 boolean predicate 값은 별도의 변수로 분리하여, 조건 내부는 간결하고 의미 있게 구성합니다.
    - 각 레이어와 함수 간 참조 관계는 간결하게 유지하며, 의존성 구조를 명확하고 엄격하게 설계합니다.
    - public 메서드에는 기능과 목적, 책임 범위, 로직 설정 이유, 발생 가능한 이슈, 참고해야 하는 클래스·메서드를 링크 형태로 주석에 기록합니다.
    - 유틸리티 클래스·메서드에도 동일한 수준의 주석을 작성하되, 입력·출력을 예상할 수 있도록 예시를 2개 이상 포함합니다.

6. **빌드 및 E2E 검증**

    - 빌드와 curl 기반 E2E 검증은 터미널 CLI를 기준으로 실행합니다.
    - 빌드 이전에 테스트 코드를 실행하며, 테스트 실패 시 테스트 수정보다 코드 베이스 수정을 우선합니다.
    - 코드 베이스 수정으로 해결할 수 없는 오류가 발생하면 인터페이스, 메서드 인자 및 테스트 케이스의 문제 여부를 점검합니다.
    - 테스트 케이스를 수정할 때는 인자 변경보다 과도한 계약 검증 여부를 확인하고 단계별로 개선합니다.
    - 기타 빌드 에러 발생 시 에러 로그를 분석하여 대응하며, 환경 설정·권한 문제·네트워크 오류 등 코드 외 요인일 경우 원인과 해결 방안을 사용자에게 정리하여 보고합니다.
    - 린트 및 포맷 관련 이슈는 사용자 요청사항에 린트·포맷 해결 요청이 없는 한 수정하지 않습니다.

## DDD 아키텍처 계층 구성 및 책임

1. **계층 구조**

    - Presentation
    - Application
    - Domain
    - Infrastructure
    - (추가) Conversion & Mapping

2. **Presentation 계층**

    - **역할**:

        - HTTP 요청 수신 및 검증
        - Controller에서 DTO를 인자로 받고, Validator를 통해 입력값 유효성 검사 수행

    - **DTO 네이밍**: `{도메인명}Request`, `{도메인명}Response`
    - **Validator 책임**:

        - 개별 필드 및 복합 규칙 검증 로직을 `Validator` 클래스로 분리
        - 유효성 실패 시 예외를 던져 상위 계층으로 전파

3. **Application 계층**

    - **역할**:

        - 유스케이스 단위 비즈니스 로직 조합·실행
        - 트랜잭션 경계 설정 및 관리

    - **입력·출력**:

        - Input: `{도메인명}Command` (데이터 변경) / `{도메인명}Query` (데이터 조회)
        - Output: `{도메인명}CommandResult` / `{도메인명}QueryResult`

    - **책임**:

        - 여러 도메인 객체 간 상호작용 조율
        - 도메인 객체 생성 및 상태 변화 호출

4. **Domain 계층**

    - **역할**:

        - 핵심 도메인 모델(엔티티·VO) 정의 및 도메인 규칙 구현

    - **네이밍**:

        - 엔티티: `User`, `Order`, `Product`
        - VO: `Email`, `UID` (접미사 없이 도메인 의미 그대로)

    - **구현 원칙**:

        - **불변 객체(Immutable)**: 상태 변경은 해당 객체 메서드를 통해 처리
        - **Aggregate Root 기반 RPO 규칙 준수**

            - 모든 엔티티·VO는 Aggregate Root를 통해서만 생성·조회·변경
            - 내부 구성 요소는 외부에서 직접 접근 금지

        - **도메인 서비스**: 외부 의존성 없는 순수 POJO로 구현, 필요 시 인터페이스·추상클래스 형태로 노출

5. **Infrastructure 계층**

    - **역할**: 외부 시스템 연동 구현

        - DB(persistence), 메시징, 외부 API 호출 등

    - **구성 예시**:

        - JPA Entity: `{도메인명}JpaEntity`
        - JPA Repository 인터페이스: `{도메인명}JpaRepository`
        - Query‑DSL: `{도메인명}QdslRepository`
        - 구현체: `{도메인명}RepositoryImpl`

6. **Conversion & Mapping**

    - **DTO ↔ Command/Result 변환**

        - 상위 계층에서 하위 계층으로의 의존성 방향을 따름
        - `RequestDTO` → `Command`
        - `CommandResult` → `ResponseDTO` (예: `ResponseDTO.from(commandResult)`)

    - **CommandResult ↔ Domain 변환**

        - `CommandResult.from(domainEntity)` 메서드를 통해 도메인 결과 추출

    - **Domain ↔ JPA Entity 변환**

        - `Mapper` 인터페이스 (`{도메인명}Mapper`) 및 구현체 (`{도메인명}MapperImpl`) 에서 처리
        - 인프라 계층에 위치시키고, 의존성 방향을 위반하지 않도록 구성
